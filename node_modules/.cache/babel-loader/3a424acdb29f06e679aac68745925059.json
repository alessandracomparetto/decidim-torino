{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nimport \"src/decidim/vendor/jquery-tmpl\";\nimport * as L from \"leaflet\";\nimport MapController from \"src/decidim/map/controller\";\nimport \"leaflet.markercluster\";\n\nvar MapMarkersController = /*#__PURE__*/function (_MapController) {\n  _inherits(MapMarkersController, _MapController);\n\n  var _super = _createSuper(MapMarkersController);\n\n  function MapMarkersController() {\n    _classCallCheck(this, MapMarkersController);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(MapMarkersController, [{\n    key: \"start\",\n    value: function start() {\n      this.markerClusters = null;\n\n      if (Array.isArray(this.config.markers) && this.config.markers.length > 0) {\n        this.addMarkers(this.config.markers);\n      } else {\n        this.map.fitWorld();\n      }\n    }\n  }, {\n    key: \"addMarkers\",\n    value: function addMarkers(markersData) {\n      var _this = this;\n\n      if (this.markerClusters === null) {\n        this.markerClusters = new L.MarkerClusterGroup();\n        this.map.addLayer(this.markerClusters);\n      } // Pre-compiles the template\n\n\n      $.template(this.config.popupTemplateId, $(\"#\".concat(this.config.popupTemplateId)).html());\n      var bounds = new L.LatLngBounds(markersData.map(function (markerData) {\n        return [markerData.latitude, markerData.longitude];\n      }));\n      markersData.forEach(function (markerData) {\n        var marker = new L.Marker([markerData.latitude, markerData.longitude], {\n          icon: _this.createIcon(),\n          keyboard: true,\n          title: markerData.title\n        });\n        var node = document.createElement(\"div\");\n        $.tmpl(_this.config.popupTemplateId, markerData).appendTo(node);\n        marker.bindPopup(node, {\n          maxwidth: 640,\n          minWidth: 500,\n          keepInView: true,\n          className: \"map-info\"\n        }).openPopup();\n\n        _this.markerClusters.addLayer(marker);\n      }); // Make sure there is enough space in the map for the padding to be\n      // applied. Otherwise the map will automatically zoom out (test it on\n      // mobile). Make sure there is at least the same amount of width and\n      // height available on both sides + the padding (i.e. 4x padding in\n      // total).\n\n      var size = this.map.getSize();\n\n      if (size.y >= 400 && size.x >= 400) {\n        this.map.fitBounds(bounds, {\n          padding: [100, 100]\n        });\n      } else if (size.y >= 120 && size.x >= 120) {\n        this.map.fitBounds(bounds, {\n          padding: [30, 30]\n        });\n      } else {\n        this.map.fitBounds(bounds);\n      }\n    }\n  }, {\n    key: \"clearMarkers\",\n    value: function clearMarkers() {\n      this.map.removeLayer(this.markerClusters);\n      this.markerClusters = new L.MarkerClusterGroup();\n      this.map.addLayer(this.markerClusters);\n    }\n  }]);\n\n  return MapMarkersController;\n}(MapController);\n\nexport { MapMarkersController as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,gCAAP;AACA,OAAO,KAAKA,CAAZ,MAAmB,SAAnB;AACA,OAAOC,aAAP,MAA0B,4BAA1B;AACA,OAAO,uBAAP;;IAEqBC,oB;;;;;;;;;;;;;WACnB,iBAAQ;AACN,WAAKC,cAAL,GAAsB,IAAtB;;AAEA,UAAIC,KAAK,CAACC,OAAND,CAAc,KAAKE,MAAL,CAAYC,OAA1BH,KAAsC,KAAKE,MAAL,CAAYC,OAAZ,CAAoBC,MAApB,GAA6B,CAAvE,EAA0E;AACxE,aAAKC,UAAL,CAAgB,KAAKH,MAAL,CAAYC,OAA5B;AADF,aAEO;AACL,aAAKG,GAAL,CAASC,QAAT;AACD;AACF;;;WAED,oBAAWC,WAAX,EAAwB;AAAA;;AACtB,UAAI,KAAKT,cAAL,KAAwB,IAA5B,EAAkC;AAChC,aAAKA,cAAL,GAAsB,IAAIH,CAAC,CAACa,kBAAN,EAAtB;AACA,aAAKH,GAAL,CAASI,QAAT,CAAkB,KAAKX,cAAvB;AAHoB,QAMtB;;;AACAY,OAAC,CAACC,QAAFD,CACE,KAAKT,MAAL,CAAYW,eADdF,EAEEA,CAAC,YAAK,KAAKT,MAAL,CAAYW,eAAjB,EAADF,CAAqCG,IAArCH,EAFFA;AAKA,UAAMI,MAAM,GAAG,IAAInB,CAAC,CAACoB,YAAN,CACbR,WAAW,CAACF,GAAZE,CACE,UAACS,UAAD;AAAA,eAAgB,CAACA,UAAU,CAACC,QAAZ,EAAsBD,UAAU,CAACE,SAAjC,CAAhB;AADF,QADa,CAAf;AAMAX,iBAAW,CAACY,OAAZZ,CAAoB,UAACS,UAAD,EAAgB;AAClC,YAAII,MAAM,GAAG,IAAIzB,CAAC,CAAC0B,MAAN,CAAa,CAACL,UAAU,CAACC,QAAZ,EAAsBD,UAAU,CAACE,SAAjC,CAAb,EAA0D;AACrEI,cAAI,EAAEC,KAAI,CAACC,UAAL,EAD+D;AAErEC,kBAAQ,EAAE,IAF2D;AAGrEC,eAAK,EAAEV,UAAU,CAACU;AAHmD,SAA1D,CAAb;AAMA,YAAIC,IAAI,GAAGC,QAAQ,CAACC,aAATD,CAAuB,KAAvBA,CAAX;AAEAlB,SAAC,CAACoB,IAAFpB,CAAOa,KAAI,CAACtB,MAAL,CAAYW,eAAnBF,EAAoCM,UAApCN,EAAgDqB,QAAhDrB,CAAyDiB,IAAzDjB;AACAU,cAAM,CAACY,SAAPZ,CAAiBO,IAAjBP,EAAuB;AACrBa,kBAAQ,EAAE,GADW;AAErBC,kBAAQ,EAAE,GAFW;AAGrBC,oBAAU,EAAE,IAHS;AAIrBC,mBAAS,EAAE;AAJU,SAAvBhB,EAKGiB,SALHjB;;AAOAG,aAAI,CAACzB,cAAL,CAAoBW,QAApB,CAA6BW,MAA7B;AAjBF,SAlBsB,CAsCtB;AACA;AACA;AACA;AACA;;AACA,UAAMkB,IAAI,GAAG,KAAKjC,GAAL,CAASkC,OAAT,EAAb;;AACA,UAAID,IAAI,CAACE,CAALF,IAAU,GAAVA,IAAiBA,IAAI,CAACG,CAALH,IAAU,GAA/B,EAAoC;AAClC,aAAKjC,GAAL,CAASqC,SAAT,CAAmB5B,MAAnB,EAA2B;AAAE6B,iBAAO,EAAE,CAAC,GAAD,EAAM,GAAN;AAAX,SAA3B;AADF,aAEO,IAAIL,IAAI,CAACE,CAALF,IAAU,GAAVA,IAAiBA,IAAI,CAACG,CAALH,IAAU,GAA/B,EAAoC;AACzC,aAAKjC,GAAL,CAASqC,SAAT,CAAmB5B,MAAnB,EAA2B;AAAE6B,iBAAO,EAAE,CAAC,EAAD,EAAK,EAAL;AAAX,SAA3B;AADK,aAEA;AACL,aAAKtC,GAAL,CAASqC,SAAT,CAAmB5B,MAAnB;AACD;AACF;;;WAED,wBAAe;AACb,WAAKT,GAAL,CAASuC,WAAT,CAAqB,KAAK9C,cAA1B;AACA,WAAKA,cAAL,GAAsB,IAAIH,CAAC,CAACa,kBAAN,EAAtB;AACA,WAAKH,GAAL,CAASI,QAAT,CAAkB,KAAKX,cAAvB;AACD;;;;EApE+CF,a;;SAA7BC,oB","names":["L","MapController","MapMarkersController","markerClusters","Array","isArray","config","markers","length","addMarkers","map","fitWorld","markersData","MarkerClusterGroup","addLayer","$","template","popupTemplateId","html","bounds","LatLngBounds","markerData","latitude","longitude","forEach","marker","Marker","icon","_this","createIcon","keyboard","title","node","document","createElement","tmpl","appendTo","bindPopup","maxwidth","minWidth","keepInView","className","openPopup","size","getSize","y","x","fitBounds","padding","removeLayer"],"sources":["/var/lib/gems/2.7.0/gems/decidim-core-0.26.0/app/packs/src/decidim/map/controller/markers.js"],"sourcesContent":["import \"src/decidim/vendor/jquery-tmpl\"\nimport * as L from \"leaflet\";\nimport MapController from \"src/decidim/map/controller\"\nimport \"leaflet.markercluster\";\n\nexport default class MapMarkersController extends MapController {\n  start() {\n    this.markerClusters = null;\n\n    if (Array.isArray(this.config.markers) && this.config.markers.length > 0) {\n      this.addMarkers(this.config.markers);\n    } else {\n      this.map.fitWorld();\n    }\n  }\n\n  addMarkers(markersData) {\n    if (this.markerClusters === null) {\n      this.markerClusters = new L.MarkerClusterGroup();\n      this.map.addLayer(this.markerClusters);\n    }\n\n    // Pre-compiles the template\n    $.template(\n      this.config.popupTemplateId,\n      $(`#${this.config.popupTemplateId}`).html()\n    );\n\n    const bounds = new L.LatLngBounds(\n      markersData.map(\n        (markerData) => [markerData.latitude, markerData.longitude]\n      )\n    );\n\n    markersData.forEach((markerData) => {\n      let marker = new L.Marker([markerData.latitude, markerData.longitude], {\n        icon: this.createIcon(),\n        keyboard: true,\n        title: markerData.title\n      });\n\n      let node = document.createElement(\"div\");\n\n      $.tmpl(this.config.popupTemplateId, markerData).appendTo(node);\n      marker.bindPopup(node, {\n        maxwidth: 640,\n        minWidth: 500,\n        keepInView: true,\n        className: \"map-info\"\n      }).openPopup();\n\n      this.markerClusters.addLayer(marker);\n    });\n\n    // Make sure there is enough space in the map for the padding to be\n    // applied. Otherwise the map will automatically zoom out (test it on\n    // mobile). Make sure there is at least the same amount of width and\n    // height available on both sides + the padding (i.e. 4x padding in\n    // total).\n    const size = this.map.getSize();\n    if (size.y >= 400 && size.x >= 400) {\n      this.map.fitBounds(bounds, { padding: [100, 100] });\n    } else if (size.y >= 120 && size.x >= 120) {\n      this.map.fitBounds(bounds, { padding: [30, 30] });\n    } else {\n      this.map.fitBounds(bounds);\n    }\n  }\n\n  clearMarkers() {\n    this.map.removeLayer(this.markerClusters);\n    this.markerClusters = new L.MarkerClusterGroup();\n    this.map.addLayer(this.markerClusters);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}