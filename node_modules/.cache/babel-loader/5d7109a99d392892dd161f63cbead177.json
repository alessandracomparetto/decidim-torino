{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n/* eslint-disable require-jsdoc */\n\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\";\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\";\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\";\nimport HistoryOverride from \"src/decidim/editor/history_override\"; // Disable warning messages from overwritting modules\n\nQuill.debug(\"error\"); // It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\n\nvar Delta = Quill[\"import\"](\"delta\");\nvar Break = Quill[\"import\"](\"blots/break\");\nvar Embed = Quill[\"import\"](\"blots/embed\");\nvar Scroll = Quill[\"import\"](\"blots/scroll\");\nvar Parchment = Quill[\"import\"](\"parchment\");\nQuill.register({\n  \"modules/history\": HistoryOverride\n}, true);\nvar icons = Quill[\"import\"](\"ui/icons\");\nicons.linebreak = \"⏎\";\n\nvar SmartBreak = /*#__PURE__*/function (_Break) {\n  _inherits(SmartBreak, _Break);\n\n  var _super = _createSuper(SmartBreak);\n\n  function SmartBreak() {\n    _classCallCheck(this, SmartBreak);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SmartBreak, [{\n    key: \"length\",\n    value: function length() {\n      return 1;\n    }\n  }, {\n    key: \"value\",\n    value: function value() {\n      return \"\\n\";\n    }\n  }, {\n    key: \"insertInto\",\n    value: function insertInto(parent, ref) {\n      // Embed.prototype.insertInto.call(this, parent, ref);\n      Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n    }\n  }]);\n\n  return SmartBreak;\n}(Break);\n\nQuill.register(SmartBreak); // Override quill/blots/scroll.js\n\nvar ScrollOvderride = /*#__PURE__*/function (_Scroll) {\n  _inherits(ScrollOvderride, _Scroll);\n\n  var _super2 = _createSuper(ScrollOvderride);\n\n  function ScrollOvderride() {\n    _classCallCheck(this, ScrollOvderride);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ScrollOvderride, [{\n    key: \"optimize\",\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.batch === true) {\n        return;\n      }\n\n      this.parchmentOptimize(mutations, context);\n\n      if (mutations.length > 0) {\n        // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n        this.emitter.emit(\"scroll-optimize\", mutations, context);\n      }\n    } // Override parchment/src/blot/scroll.ts\n\n  }, {\n    key: \"parchmentOptimize\",\n    value: function parchmentOptimize() {\n      var _this = this;\n\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // super.optimize(context);\n\n      Reflect.apply(Parchment.Container.prototype.optimize, this, [context]); // We must modify mutations directly, cannot make copy and then modify\n      // let records = [].slice.call(this.observer.takeRecords());\n\n      var records = _toConsumableArray(this.observer.takeRecords()); // Array.push currently seems to be implemented by a non-tail recursive function\n      // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n\n\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n\n      var mark = function mark(blot, markParent) {\n        if (!blot || blot === _this) {\n          return;\n        }\n\n        if (!blot.domNode.parentNode) {\n          return;\n        }\n\n        if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n          blot.domNode.__blot.mutations = [];\n        }\n\n        if (markParent) {\n          mark(blot.parent);\n        }\n      };\n\n      var optimize = function optimize(blot) {\n        // Post-order traversal\n        if (!blot.domNode.__blot) {\n          return;\n        }\n\n        if (blot instanceof Parchment.Container) {\n          blot.children.forEach(optimize);\n        }\n\n        blot.optimize(context);\n      };\n\n      var remaining = mutations;\n\n      for (var ind = 0; remaining.length > 0; ind += 1) {\n        // MAX_OPTIMIZE_ITERATIONS = 100\n        if (ind >= 100) {\n          throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n        }\n\n        remaining.forEach(function (mutation) {\n          var blot = Parchment.find(mutation.target, true);\n\n          if (!blot) {\n            return;\n          }\n\n          if (blot.domNode === mutation.target) {\n            if (mutation.type === \"childList\") {\n              mark(Parchment.find(mutation.previousSibling, false));\n              mutation.addedNodes.forEach(function (node) {\n                var child = Parchment.find(node, false);\n                mark(child, false);\n\n                if (child instanceof Parchment.Container) {\n                  child.children.forEach(function (grandChild) {\n                    mark(grandChild, false);\n                  });\n                }\n              });\n            } else if (mutation.type === \"attributes\") {\n              mark(blot.prev);\n            }\n          }\n\n          mark(blot);\n        });\n        this.children.forEach(optimize);\n        remaining = _toConsumableArray(this.observer.takeRecords());\n        records = remaining.slice();\n\n        while (records.length > 0) {\n          mutations.push(records.pop());\n        }\n      }\n    }\n  }]);\n\n  return ScrollOvderride;\n}(Scroll);\n\n;\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\nexport default function lineBreakButtonHandler(quill) {\n  var range = quill.selection.getRange()[0];\n  var currentLeaf = quill.getLeaf(range.index)[0];\n  var nextLeaf = quill.getLeaf(range.index + 1)[0];\n  var previousChar = quill.getText(range.index - 1, 1); // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n\n  if (nextLeaf === null || currentLeaf.parent !== nextLeaf.parent) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    var delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } // Now that we've inserted a line break, move the cursor forward\n\n\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\nQuill.register(\"modules/linebreak\", function (quill) {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", function () {\n    lineBreakButtonHandler(quill);\n  });\n  quill.emitter.on(\"editor-ready\", function () {\n    var length = quill.getLength();\n    var text = quill.getText(length - 2, 2); // Remove extraneous new lines\n\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n  quill.clipboard.addMatcher(\"BR\", function (node) {\n    var _node$parentNode;\n\n    if ((node === null || node === void 0 ? void 0 : (_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.tagName) === \"A\") {\n      return new Delta().insert(\"\\n\");\n    }\n\n    return new Delta().insert({\n      \"break\": \"\"\n    });\n  });\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n  return;\n});","map":{"version":3,"mappings":"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","names":["addEnterBindings","backspaceBindingsRangeAny","backspaceBindings","HistoryOverride","Quill","debug","Delta","Break","Embed","Scroll","Parchment","register","icons","linebreak","SmartBreak","parent","ref","Reflect","apply","prototype","insertInto","ScrollOvderride","mutations","context","batch","parchmentOptimize","length","emitter","emit","Container","optimize","records","observer","takeRecords","push","pop","mark","blot","markParent","_this","domNode","parentNode","__blot","children","forEach","remaining","ind","Error","mutation","find","target","type","previousSibling","addedNodes","node","child","grandChild","prev","slice","lineBreakButtonHandler","quill","range","selection","getRange","currentLeaf","getLeaf","index","nextLeaf","previousChar","getText","insertEmbed","delta","retain","insert","updateContents","sources","USER","setSelection","SILENT","getModule","addHandler","on","getLength","text","deleteText","clipboard","addMatcher","tagName"],"sources":["/var/lib/gems/2.7.0/gems/decidim-core-0.26.0/app/packs/src/decidim/editor/linebreak_module.js"],"sourcesContent":["/* eslint-disable require-jsdoc */\n\nimport addEnterBindings from \"src/decidim/editor/modified_enter\"\nimport backspaceBindingsRangeAny from \"src/decidim/editor/modified_backspace_offset_any\"\nimport backspaceBindings from \"src/decidim/editor/modified_backspace_offset1\"\nimport HistoryOverride from \"src/decidim/editor/history_override\"\n\n// Disable warning messages from overwritting modules\nQuill.debug(\"error\");\n\n// It all started with these snippets of code: https://github.com/quilljs/quill/issues/252\nconst Delta = Quill.import(\"delta\");\nconst Break = Quill.import(\"blots/break\");\nconst Embed = Quill.import(\"blots/embed\");\nconst Scroll = Quill.import(\"blots/scroll\");\nconst Parchment = Quill.import(\"parchment\");\nQuill.register({\"modules/history\": HistoryOverride}, true);\nlet icons = Quill.import(\"ui/icons\");\nicons.linebreak = \"⏎\";\n\nclass SmartBreak extends Break {\n  length() {\n    return 1;\n  }\n\n  value() {\n    return \"\\n\";\n  }\n\n  insertInto(parent, ref) {\n    // Embed.prototype.insertInto.call(this, parent, ref);\n    Reflect.apply(Embed.prototype.insertInto, this, [parent, ref]);\n  }\n}\nQuill.register(SmartBreak);\n\n// Override quill/blots/scroll.js\nclass ScrollOvderride extends Scroll {\n  optimize(mutations = [], context = {}) {\n    if (this.batch === true) {\n      return;\n    }\n\n    this.parchmentOptimize(mutations, context);\n\n    if (mutations.length > 0) {\n      // quill/core/emitter.js, Emitter.events.SCROLL_OPTIMIZE = \"scroll-optimize\"\n      this.emitter.emit(\"scroll-optimize\", mutations, context);\n    }\n  }\n\n  // Override parchment/src/blot/scroll.ts\n  parchmentOptimize(mutations = [], context = {}) {\n    // super.optimize(context);\n    Reflect.apply(Parchment.Container.prototype.optimize, this, [context]);\n\n    // We must modify mutations directly, cannot make copy and then modify\n    // let records = [].slice.call(this.observer.takeRecords());\n    let records = [...this.observer.takeRecords()];\n    // Array.push currently seems to be implemented by a non-tail recursive function\n    // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n    while (records.length > 0) {\n      mutations.push(records.pop());\n    }\n    let mark = (blot, markParent) => {\n      if (!blot || blot === this) {\n        return;\n      }\n      if (!blot.domNode.parentNode) {\n        return;\n      }\n      if (blot.domNode.__blot && blot.domNode.__blot.mutations === null) {\n        blot.domNode.__blot.mutations = [];\n      }\n      if (markParent) {\n        mark(blot.parent);\n      }\n    };\n    let optimize = (blot) => {\n      // Post-order traversal\n      if (!blot.domNode.__blot) {\n        return;\n      }\n\n      if (blot instanceof Parchment.Container) {\n        blot.children.forEach(optimize);\n      }\n      blot.optimize(context);\n    };\n    let remaining = mutations;\n    for (let ind = 0; remaining.length > 0; ind += 1) {\n      // MAX_OPTIMIZE_ITERATIONS = 100\n      if (ind >= 100) {\n        throw new Error(\"[Parchment] Maximum optimize iterations reached\");\n      }\n      remaining.forEach((mutation) => {\n        let blot = Parchment.find(mutation.target, true);\n        if (!blot) {\n          return;\n        }\n        if (blot.domNode === mutation.target) {\n          if (mutation.type === \"childList\") {\n            mark(Parchment.find(mutation.previousSibling, false));\n\n            mutation.addedNodes.forEach((node) => {\n              let child = Parchment.find(node, false);\n              mark(child, false);\n              if (child instanceof Parchment.Container) {\n                child.children.forEach(function(grandChild) {\n                  mark(grandChild, false);\n                });\n              }\n            });\n          } else if (mutation.type === \"attributes\") {\n            mark(blot.prev);\n          }\n        }\n        mark(blot);\n      });\n      this.children.forEach(optimize);\n      remaining = [...this.observer.takeRecords()];\n      records = remaining.slice();\n      while (records.length > 0) {\n        mutations.push(records.pop());\n      }\n    }\n  }\n};\nQuill.register(\"blots/scroll\", ScrollOvderride, true);\nParchment.register(ScrollOvderride);\n\n\nexport default function lineBreakButtonHandler(quill) {\n  let range = quill.selection.getRange()[0];\n  let currentLeaf = quill.getLeaf(range.index)[0];\n  let nextLeaf = quill.getLeaf(range.index + 1)[0];\n  const previousChar = quill.getText(range.index - 1, 1);\n\n  // Insert a second break if:\n  // At the end of the editor, OR next leaf has a different parent (<p>)\n  if (nextLeaf === null || (currentLeaf.parent !== nextLeaf.parent)) {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  } else if (previousChar === \"\\n\") {\n    const delta = new Delta().retain(range.index).insert(\"\\n\");\n    quill.updateContents(delta, Quill.sources.USER);\n  } else {\n    quill.insertEmbed(range.index, \"break\", true, \"user\");\n  }\n\n  // Now that we've inserted a line break, move the cursor forward\n  quill.setSelection(range.index + 1, Quill.sources.SILENT);\n}\n\nQuill.register(\"modules/linebreak\", (quill) => {\n  quill.getModule(\"toolbar\").addHandler(\"linebreak\", () => {\n    lineBreakButtonHandler(quill);\n  });\n\n  quill.emitter.on(\"editor-ready\", () => {\n    const length = quill.getLength();\n    const text = quill.getText(length - 2, 2);\n\n    // Remove extraneous new lines\n    if (text === \"\\n\\n\") {\n      quill.deleteText(quill.getLength() - 2, 2);\n    }\n  });\n\n  quill.clipboard.addMatcher(\"BR\", (node) => {\n    if (node?.parentNode?.tagName === \"A\") {\n      return new Delta().insert(\"\\n\");\n    }\n    return new Delta().insert({\"break\": \"\"});\n  });\n\n  addEnterBindings(quill);\n  backspaceBindingsRangeAny(quill);\n  backspaceBindings(quill);\n\n  return;\n});\n\n"]},"metadata":{},"sourceType":"module"}