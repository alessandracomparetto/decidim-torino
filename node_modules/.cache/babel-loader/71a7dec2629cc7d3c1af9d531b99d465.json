{"ast":null,"code":"/* eslint-disable */\n\n/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n;\n\n(function (jQuery, undefined) {\n  var oldManip = jQuery.fn.domManip,\n      tmplItmAtt = \"_tmplitem\",\n      htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n      newTmplItems = {},\n      wrappedItems = {},\n      appendToTmplItems,\n      topTmplItem = {\n    key: 0,\n    data: {}\n  },\n      itemKey = 0,\n      cloneIndex = 0,\n      stack = [];\n\n  function newTmplItem(options, parentItem, fn, data) {\n    // Returns a template item data structure for a new rendered instance of a template (a 'template item').\n    // The content field is a hierarchical array of strings and nested items (to be\n    // removed and replaced by nodes field of dom elements, once inserted in DOM).\n    var newItem = {\n      data: data || (parentItem ? parentItem.data : {}),\n      _wrap: parentItem ? parentItem._wrap : null,\n      tmpl: null,\n      parent: parentItem || null,\n      nodes: [],\n      calls: tiCalls,\n      nest: tiNest,\n      wrap: tiWrap,\n      html: tiHtml,\n      update: tiUpdate\n    };\n\n    if (options) {\n      jQuery.extend(newItem, options, {\n        nodes: [],\n        parent: parentItem\n      });\n    }\n\n    if (fn) {\n      // Build the hierarchical content to be used during insertion into DOM\n      newItem.tmpl = fn;\n      newItem._ctnt = newItem._ctnt || newItem.tmpl(jQuery, newItem);\n      newItem.key = ++itemKey; // Keep track of new template item, until it is stored as jQuery Data on DOM element\n\n      (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n    }\n\n    return newItem;\n  } // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n\n\n  jQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n  }, function (name, original) {\n    jQuery.fn[name] = function (selector) {\n      var ret = [],\n          insert = jQuery(selector),\n          elems,\n          i,\n          l,\n          tmplItems,\n          parent = this.length === 1 && this[0].parentNode;\n      appendToTmplItems = newTmplItems || {};\n\n      if (parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1) {\n        insert[original](this[0]);\n        ret = this;\n      } else {\n        for (i = 0, l = insert.length; i < l; i++) {\n          cloneIndex = i;\n          elems = (i > 0 ? this.clone(true) : this).get();\n          jQuery.fn[original].apply(jQuery(insert[i]), elems);\n          ret = ret.concat(elems);\n        }\n\n        cloneIndex = 0;\n        ret = this.pushStack(ret, name, insert.selector);\n      }\n\n      tmplItems = appendToTmplItems;\n      appendToTmplItems = null;\n      jQuery.tmpl.complete(tmplItems);\n      return ret;\n    };\n  });\n  jQuery.fn.extend({\n    // Use first wrapped element as template markup.\n    // Return wrapped set of template items, obtained by rendering template against data.\n    tmpl: function tmpl(data, options, parentItem) {\n      return jQuery.tmpl(this[0], data, options, parentItem);\n    },\n    // Find which rendered template item the first wrapped DOM element belongs to\n    tmplItem: function tmplItem() {\n      return jQuery.tmplItem(this[0]);\n    },\n    // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n    template: function template(name) {\n      return jQuery.template(name, this[0]);\n    },\n    domManip: function domManip(args, table, callback, options) {\n      // This appears to be a bug in the appendTo, etc. implementation\n      // it should be doing .call() instead of .apply(). See #6227\n      if (args[0] && args[0].nodeType) {\n        var dmArgs = jQuery.makeArray(arguments),\n            argsLength = args.length,\n            i = 0,\n            tmplItem;\n\n        while (i < argsLength && !(tmplItem = jQuery.data(args[i++], \"tmplItem\"))) {}\n\n        if (argsLength > 1) {\n          dmArgs[0] = [jQuery.makeArray(args)];\n        }\n\n        if (tmplItem && cloneIndex) {\n          dmArgs[2] = function (fragClone) {\n            // Handler called by oldManip when rendered template has been inserted into DOM.\n            jQuery.tmpl.afterManip(this, fragClone, callback);\n          };\n        }\n\n        oldManip.apply(this, dmArgs);\n      } else {\n        oldManip.apply(this, arguments);\n      }\n\n      cloneIndex = 0;\n\n      if (!appendToTmplItems) {\n        jQuery.tmpl.complete(newTmplItems);\n      }\n\n      return this;\n    }\n  });\n  jQuery.extend({\n    // Return wrapped set of template items, obtained by rendering template against data.\n    tmpl: function tmpl(_tmpl, data, options, parentItem) {\n      var ret,\n          topLevel = !parentItem;\n\n      if (topLevel) {\n        // This is a top-level tmpl call (not from a nested template using {{tmpl}})\n        parentItem = topTmplItem;\n        _tmpl = jQuery.template[_tmpl] || jQuery.template(null, _tmpl);\n        wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n      } else if (!_tmpl) {\n        // The template item is already associated with DOM - this is a refresh.\n        // Re-evaluate rendered template for the parentItem\n        _tmpl = parentItem.tmpl;\n        newTmplItems[parentItem.key] = parentItem;\n        parentItem.nodes = [];\n\n        if (parentItem.wrapped) {\n          updateWrapped(parentItem, parentItem.wrapped);\n        } // Rebuild, without creating a new template item\n\n\n        return jQuery(build(parentItem, null, parentItem.tmpl(jQuery, parentItem)));\n      }\n\n      if (!_tmpl) {\n        return []; // Could throw...\n      }\n\n      if (typeof data === \"function\") {\n        data = data.call(parentItem || {});\n      }\n\n      if (options && options.wrapped) {\n        updateWrapped(options, options.wrapped);\n      }\n\n      ret = jQuery.isArray(data) ? jQuery.map(data, function (dataItem) {\n        return dataItem ? newTmplItem(options, parentItem, _tmpl, dataItem) : null;\n      }) : [newTmplItem(options, parentItem, _tmpl, data)];\n      return topLevel ? jQuery(build(parentItem, null, ret)) : ret;\n    },\n    // Return rendered template item for an element.\n    tmplItem: function tmplItem(elem) {\n      var tmplItem;\n\n      if (elem instanceof jQuery) {\n        elem = elem[0];\n      }\n\n      while (elem && elem.nodeType === 1 && !(tmplItem = jQuery.data(elem, \"tmplItem\")) && (elem = elem.parentNode)) {}\n\n      return tmplItem || topTmplItem;\n    },\n    // Set:\n    // Use $.template( name, tmpl ) to cache a named template,\n    // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n    // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n    // Get:\n    // Use $.template( name ) to access a cached template.\n    // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n    // will return the compiled template, without adding a name reference.\n    // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n    // to $.template( null, templateString )\n    template: function template(name, tmpl) {\n      if (tmpl) {\n        // Compile template and associate with name\n        if (typeof tmpl === \"string\") {\n          // This is an HTML string being passed directly in.\n          tmpl = buildTmplFn(tmpl);\n        } else if (tmpl instanceof jQuery) {\n          tmpl = tmpl[0] || {};\n        }\n\n        if (tmpl.nodeType) {\n          // If this is a template block, use cached copy, or generate tmpl function and cache.\n          tmpl = jQuery.data(tmpl, \"tmpl\") || jQuery.data(tmpl, \"tmpl\", buildTmplFn(tmpl.innerHTML));\n        }\n\n        return typeof name === \"string\" ? jQuery.template[name] = tmpl : tmpl;\n      } // Return named compiled template\n\n\n      return name ? typeof name !== \"string\" ? jQuery.template(null, name) : jQuery.template[name] || // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\n      jQuery.template(null, htmlExpr.test(name) ? name : jQuery(name)) : null;\n    },\n    encode: function encode(text) {\n      // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n      return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n    }\n  });\n  jQuery.extend(jQuery.tmpl, {\n    tag: {\n      \"tmpl\": {\n        _default: {\n          $2: \"null\"\n        },\n        open: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\" // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n        // This means that {{tmpl foo}} treats foo as a template (which IS a function).\n        // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n\n      },\n      \"wrap\": {\n        _default: {\n          $2: \"null\"\n        },\n        open: \"$item.calls(_,$1,$2);_=[];\",\n        close: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n      },\n      \"each\": {\n        _default: {\n          $2: \"$index, $value\"\n        },\n        open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n        close: \"}});}\"\n      },\n      \"if\": {\n        open: \"if(($notnull_1) && $1a){\",\n        close: \"}\"\n      },\n      \"else\": {\n        _default: {\n          $1: \"true\"\n        },\n        open: \"}else if(($notnull_1) && $1a){\"\n      },\n      \"html\": {\n        // Unecoded expression evaluation.\n        open: \"if($notnull_1){_.push($1a);}\"\n      },\n      \"=\": {\n        // Encoded expression evaluation. Abbreviated form is ${}.\n        _default: {\n          $1: \"$data\"\n        },\n        open: \"if($notnull_1){_.push($.encode($1a));}\"\n      },\n      \"!\": {\n        // Comment tag. Skipped by parser\n        open: \"\"\n      }\n    },\n    // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n    complete: function complete(items) {\n      newTmplItems = {};\n    },\n    // Call this from code which overrides domManip, or equivalent\n    // Manage cloning/storing template items etc.\n    afterManip: function afterManip(elem, fragClone, callback) {\n      // Provides cloned fragment ready for fixup prior to and after insertion into DOM\n      var content = fragClone.nodeType === 11 ? jQuery.makeArray(fragClone.childNodes) : fragClone.nodeType === 1 ? [fragClone] : []; // Return fragment to original caller (e.g. append) for DOM insertion\n\n      callback.call(elem, fragClone); // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n\n      storeTmplItems(content);\n      cloneIndex++;\n    }\n  }); //========================== Private helper functions, used by code above ==========================\n\n  function build(tmplItem, nested, content) {\n    // Convert hierarchical content into flat string array\n    // and finally return array of fragments ready for DOM insertion\n    var frag,\n        ret = content ? jQuery.map(content, function (item) {\n      return typeof item === \"string\" ? // Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n      tmplItem.key ? item.replace(/(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\") : item : // This is a child template item. Build nested template.\n      build(item, tmplItem, item._ctnt);\n    }) : // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n    tmplItem;\n\n    if (nested) {\n      return ret;\n    } // top-level template\n\n\n    ret = ret.join(\"\"); // Support templates which have initial or final text nodes, or consist only of text\n    // Also support HTML entities within the HTML markup.\n\n    ret.replace(/^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function (all, before, middle, after) {\n      frag = jQuery(middle).get();\n      storeTmplItems(frag);\n\n      if (before) {\n        frag = unencode(before).concat(frag);\n      }\n\n      if (after) {\n        frag = frag.concat(unencode(after));\n      }\n    });\n    return frag ? frag : unencode(ret);\n  }\n\n  function unencode(text) {\n    // Use createElement, since createTextNode will not render HTML entities correctly\n    var el = document.createElement(\"div\");\n    el.innerHTML = text;\n    return jQuery.makeArray(el.childNodes);\n  } // Generate a reusable function that will serve to render a template against data\n\n\n  function buildTmplFn(markup) {\n    return new Function(\"jQuery\", \"$item\", \"var $=jQuery,call,_=[],$data=$item.data;\" + // Introduce the data as local variables using with(){}\n    \"with($data){_.push('\" + // Convert the template into pure JavaScript\n    jQuery.trim(markup).replace(/([\\\\'])/g, \"\\\\$1\").replace(/[\\r\\t\\n]/g, \" \").replace(/\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\").replace(/\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g, function (all, slash, type, fnargs, target, parens, args) {\n      var tag = jQuery.tmpl.tag[type],\n          def,\n          expr,\n          exprAutoFnDetect;\n\n      if (!tag) {\n        throw \"Template command not found: \" + type;\n      }\n\n      def = tag._default || [];\n\n      if (parens && !/\\w$/.test(target)) {\n        target += parens;\n        parens = \"\";\n      }\n\n      if (target) {\n        target = unescape(target);\n        args = args ? \",\" + unescape(args) + \")\" : parens ? \")\" : \"\"; // Support for target being things like a.toLowerCase();\n        // In that case don't call with template item as 'this' pointer. Just evaluate...\n\n        expr = parens ? target.indexOf(\".\") > -1 ? target + parens : \"(\" + target + \").call($item\" + args : target;\n        exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n      } else {\n        exprAutoFnDetect = expr = def.$1 || \"null\";\n      }\n\n      fnargs = unescape(fnargs);\n      return \"');\" + tag[slash ? \"close\" : \"open\"].split(\"$notnull_1\").join(target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\").split(\"$1a\").join(exprAutoFnDetect).split(\"$1\").join(expr).split(\"$2\").join(fnargs ? fnargs.replace(/\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function (all, name, parens, params) {\n        params = params ? \",\" + params + \")\" : parens ? \")\" : \"\";\n        return params ? \"(\" + name + \").call($item\" + params : all;\n      }) : def.$2 || \"\") + \"_.push('\";\n    }) + \"');}return _;\");\n  }\n\n  function updateWrapped(options, wrapped) {\n    // Build the wrapped content.\n    options._wrap = build(options, true, // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n    jQuery.isArray(wrapped) ? wrapped : [htmlExpr.test(wrapped) ? wrapped : jQuery(wrapped).html()]).join(\"\");\n  }\n\n  function unescape(args) {\n    return args ? args.replace(/\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\") : null;\n  }\n\n  function outerHtml(elem) {\n    var div = document.createElement(\"div\");\n    div.appendChild(elem.cloneNode(true));\n    return div.innerHTML;\n  } // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n\n\n  function storeTmplItems(content) {\n    var keySuffix = \"_\" + cloneIndex,\n        elem,\n        elems,\n        newClonedItems = {},\n        i,\n        l,\n        m;\n\n    for (i = 0, l = content.length; i < l; i++) {\n      if ((elem = content[i]).nodeType !== 1) {\n        continue;\n      }\n\n      elems = elem.getElementsByTagName(\"*\");\n\n      for (m = elems.length - 1; m >= 0; m--) {\n        processItemKey(elems[m]);\n      }\n\n      processItemKey(elem);\n    }\n\n    function processItemKey(el) {\n      var pntKey,\n          pntNode = el,\n          pntItem,\n          tmplItem,\n          key; // Ensure that each rendered template inserted into the DOM has its own template item,\n\n      if (key = el.getAttribute(tmplItmAtt)) {\n        while (pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute(tmplItmAtt))) {}\n\n        if (pntKey !== key) {\n          // The next ancestor with a _tmplitem expando is on a different key than this one.\n          // So this is a top-level element within this template item\n          // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n          pntNode = pntNode.parentNode ? pntNode.nodeType === 11 ? 0 : pntNode.getAttribute(tmplItmAtt) || 0 : 0;\n\n          if (!(tmplItem = newTmplItems[key])) {\n            // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n            tmplItem = wrappedItems[key];\n            tmplItem = newTmplItem(tmplItem, newTmplItems[pntNode] || wrappedItems[pntNode], null, true);\n            tmplItem.key = ++itemKey;\n            newTmplItems[itemKey] = tmplItem;\n          }\n\n          if (cloneIndex) {\n            cloneTmplItem(key);\n          }\n        }\n\n        el.removeAttribute(tmplItmAtt);\n      } else if (cloneIndex && (tmplItem = jQuery.data(el, \"tmplItem\"))) {\n        // This was a rendered element, cloned during append or appendTo etc.\n        // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n        cloneTmplItem(tmplItem.key);\n        newTmplItems[tmplItem.key] = tmplItem;\n        pntNode = jQuery.data(el.parentNode, \"tmplItem\");\n        pntNode = pntNode ? pntNode.key : 0;\n      }\n\n      if (tmplItem) {\n        pntItem = tmplItem; // Find the template item of the parent element.\n        // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n\n        while (pntItem && pntItem.key != pntNode) {\n          // Add this element as a top-level node for this rendered template item, as well as for any\n          // ancestor items between this item and the item of its parent element\n          pntItem.nodes.push(el);\n          pntItem = pntItem.parent;\n        } // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n\n\n        delete tmplItem._ctnt;\n        delete tmplItem._wrap; // Store template item as jQuery data on the element\n\n        jQuery.data(el, \"tmplItem\", tmplItem);\n      }\n\n      function cloneTmplItem(key) {\n        key = key + keySuffix;\n        tmplItem = newClonedItems[key] = newClonedItems[key] || newTmplItem(tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true);\n      }\n    }\n  } //---- Helper functions for template item ----\n\n\n  function tiCalls(content, tmpl, data, options) {\n    if (!content) {\n      return stack.pop();\n    }\n\n    stack.push({\n      _: content,\n      tmpl: tmpl,\n      item: this,\n      data: data,\n      options: options\n    });\n  }\n\n  function tiNest(tmpl, data, options) {\n    // nested template, using {{tmpl}} tag\n    return jQuery.tmpl(jQuery.template(tmpl), data, options, this);\n  }\n\n  function tiWrap(call, wrapped) {\n    // nested template, using {{wrap}} tag\n    var options = call.options || {};\n    options.wrapped = wrapped; // Apply the template, which may incorporate wrapped content,\n\n    return jQuery.tmpl(jQuery.template(call.tmpl), call.data, options, call.item);\n  }\n\n  function tiHtml(filter, textOnly) {\n    var wrapped = this._wrap;\n    return jQuery.map(jQuery(jQuery.isArray(wrapped) ? wrapped.join(\"\") : wrapped).filter(filter || \"*\"), function (e) {\n      return textOnly ? e.innerText || e.textContent : e.outerHTML || outerHtml(e);\n    });\n  }\n\n  function tiUpdate() {\n    var coll = this.nodes;\n    jQuery.tmpl(null, null, null, this).insertBefore(coll[0]);\n    jQuery(coll).remove();\n  }\n})(jQuery);","map":{"version":3,"mappings":"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","names":["jQuery","undefined","oldManip","fn","domManip","tmplItmAtt","htmlExpr","newTmplItems","wrappedItems","appendToTmplItems","topTmplItem","key","data","itemKey","cloneIndex","stack","newTmplItem","options","parentItem","newItem","_wrap","tmpl","parent","nodes","calls","tiCalls","nest","tiNest","wrap","tiWrap","html","tiHtml","update","tiUpdate","extend","_ctnt","length","each","appendTo","prependTo","insertBefore","insertAfter","replaceAll","name","original","selector","ret","insert","elems","i","l","tmplItems","parentNode","nodeType","childNodes","clone","get","apply","concat","pushStack","complete","tmplItem","template","args","table","callback","dmArgs","makeArray","arguments","argsLength","fragClone","afterManip","topLevel","wrapped","updateWrapped","build","call","isArray","map","dataItem","elem","buildTmplFn","innerHTML","test","encode","text","split","join","tag","_default","$2","open","close","$1","items","content","storeTmplItems","nested","frag","item","replace","all","before","middle","after","unencode","el","document","createElement","markup","Function","trim","slash","type","fnargs","target","parens","def","expr","exprAutoFnDetect","unescape","indexOf","params","outerHtml","div","appendChild","cloneNode","keySuffix","newClonedItems","m","getElementsByTagName","processItemKey","pntKey","pntNode","pntItem","getAttribute","cloneTmplItem","removeAttribute","push","pop","_","filter","textOnly","e","innerText","textContent","outerHTML","coll","remove"],"sources":["/var/lib/gems/2.7.0/gems/decidim-core-0.26.0/app/packs/src/decidim/vendor/jquery-tmpl.js"],"sourcesContent":["/* eslint-disable */\n\n/*\n * jQuery Templating Plugin\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n */\n;(function( jQuery, undefined ){\n    var oldManip = jQuery.fn.domManip, tmplItmAtt = \"_tmplitem\", htmlExpr = /^[^<]*(<[\\w\\W]+>)[^>]*$|\\{\\{\\! /,\n        newTmplItems = {}, wrappedItems = {}, appendToTmplItems, topTmplItem = { key: 0, data: {} }, itemKey = 0, cloneIndex = 0, stack = [];\n\n    function newTmplItem( options, parentItem, fn, data ) {\n        // Returns a template item data structure for a new rendered instance of a template (a 'template item').\n        // The content field is a hierarchical array of strings and nested items (to be\n        // removed and replaced by nodes field of dom elements, once inserted in DOM).\n        var newItem = {\n            data: data || (parentItem ? parentItem.data : {}),\n            _wrap: parentItem ? parentItem._wrap : null,\n            tmpl: null,\n            parent: parentItem || null,\n            nodes: [],\n            calls: tiCalls,\n            nest: tiNest,\n            wrap: tiWrap,\n            html: tiHtml,\n            update: tiUpdate\n        };\n        if ( options ) {\n            jQuery.extend( newItem, options, { nodes: [], parent: parentItem } );\n        }\n        if ( fn ) {\n            // Build the hierarchical content to be used during insertion into DOM\n            newItem.tmpl = fn;\n            newItem._ctnt = newItem._ctnt || newItem.tmpl( jQuery, newItem );\n            newItem.key = ++itemKey;\n            // Keep track of new template item, until it is stored as jQuery Data on DOM element\n            (stack.length ? wrappedItems : newTmplItems)[itemKey] = newItem;\n        }\n        return newItem;\n    }\n\n    // Override appendTo etc., in order to provide support for targeting multiple elements. (This code would disappear if integrated in jquery core).\n    jQuery.each({\n        appendTo: \"append\",\n        prependTo: \"prepend\",\n        insertBefore: \"before\",\n        insertAfter: \"after\",\n        replaceAll: \"replaceWith\"\n    }, function( name, original ) {\n        jQuery.fn[ name ] = function( selector ) {\n            var ret = [], insert = jQuery( selector ), elems, i, l, tmplItems,\n                parent = this.length === 1 && this[0].parentNode;\n\n            appendToTmplItems = newTmplItems || {};\n            if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {\n                insert[ original ]( this[0] );\n                ret = this;\n            } else {\n                for ( i = 0, l = insert.length; i < l; i++ ) {\n                    cloneIndex = i;\n                    elems = (i > 0 ? this.clone(true) : this).get();\n                    jQuery.fn[ original ].apply( jQuery(insert[i]), elems );\n                    ret = ret.concat( elems );\n                }\n                cloneIndex = 0;\n                ret = this.pushStack( ret, name, insert.selector );\n            }\n            tmplItems = appendToTmplItems;\n            appendToTmplItems = null;\n            jQuery.tmpl.complete( tmplItems );\n            return ret;\n        };\n    });\n\n    jQuery.fn.extend({\n        // Use first wrapped element as template markup.\n        // Return wrapped set of template items, obtained by rendering template against data.\n        tmpl: function( data, options, parentItem ) {\n            return jQuery.tmpl( this[0], data, options, parentItem );\n        },\n\n        // Find which rendered template item the first wrapped DOM element belongs to\n        tmplItem: function() {\n            return jQuery.tmplItem( this[0] );\n        },\n\n        // Consider the first wrapped element as a template declaration, and get the compiled template or store it as a named template.\n        template: function( name ) {\n            return jQuery.template( name, this[0] );\n        },\n\n        domManip: function( args, table, callback, options ) {\n            // This appears to be a bug in the appendTo, etc. implementation\n            // it should be doing .call() instead of .apply(). See #6227\n            if ( args[0] && args[0].nodeType ) {\n                var dmArgs = jQuery.makeArray( arguments ), argsLength = args.length, i = 0, tmplItem;\n                while ( i < argsLength && !(tmplItem = jQuery.data( args[i++], \"tmplItem\" ))) {}\n                if ( argsLength > 1 ) {\n                    dmArgs[0] = [jQuery.makeArray( args )];\n                }\n                if ( tmplItem && cloneIndex ) {\n                    dmArgs[2] = function( fragClone ) {\n                        // Handler called by oldManip when rendered template has been inserted into DOM.\n                        jQuery.tmpl.afterManip( this, fragClone, callback );\n                    };\n                }\n                oldManip.apply( this, dmArgs );\n            } else {\n                oldManip.apply( this, arguments );\n            }\n            cloneIndex = 0;\n            if ( !appendToTmplItems ) {\n                jQuery.tmpl.complete( newTmplItems );\n            }\n            return this;\n        }\n    });\n\n    jQuery.extend({\n        // Return wrapped set of template items, obtained by rendering template against data.\n        tmpl: function( tmpl, data, options, parentItem ) {\n            var ret, topLevel = !parentItem;\n            if ( topLevel ) {\n                // This is a top-level tmpl call (not from a nested template using {{tmpl}})\n                parentItem = topTmplItem;\n                tmpl = jQuery.template[tmpl] || jQuery.template( null, tmpl );\n                wrappedItems = {}; // Any wrapped items will be rebuilt, since this is top level\n            } else if ( !tmpl ) {\n                // The template item is already associated with DOM - this is a refresh.\n                // Re-evaluate rendered template for the parentItem\n                tmpl = parentItem.tmpl;\n                newTmplItems[parentItem.key] = parentItem;\n                parentItem.nodes = [];\n                if ( parentItem.wrapped ) {\n                    updateWrapped( parentItem, parentItem.wrapped );\n                }\n                // Rebuild, without creating a new template item\n                return jQuery( build( parentItem, null, parentItem.tmpl( jQuery, parentItem ) ));\n            }\n            if ( !tmpl ) {\n                return []; // Could throw...\n            }\n            if ( typeof data === \"function\" ) {\n                data = data.call( parentItem || {} );\n            }\n            if ( options && options.wrapped ) {\n                updateWrapped( options, options.wrapped );\n            }\n            ret = jQuery.isArray( data ) ?\n                jQuery.map( data, function( dataItem ) {\n                    return dataItem ? newTmplItem( options, parentItem, tmpl, dataItem ) : null;\n                }) :\n                [ newTmplItem( options, parentItem, tmpl, data ) ];\n            return topLevel ? jQuery( build( parentItem, null, ret ) ) : ret;\n        },\n\n        // Return rendered template item for an element.\n        tmplItem: function( elem ) {\n            var tmplItem;\n            if ( elem instanceof jQuery ) {\n                elem = elem[0];\n            }\n            while ( elem && elem.nodeType === 1 && !(tmplItem = jQuery.data( elem, \"tmplItem\" )) && (elem = elem.parentNode) ) {}\n            return tmplItem || topTmplItem;\n        },\n\n        // Set:\n        // Use $.template( name, tmpl ) to cache a named template,\n        // where tmpl is a template string, a script element or a jQuery instance wrapping a script element, etc.\n        // Use $( \"selector\" ).template( name ) to provide access by name to a script block template declaration.\n\n        // Get:\n        // Use $.template( name ) to access a cached template.\n        // Also $( selectorToScriptBlock ).template(), or $.template( null, templateString )\n        // will return the compiled template, without adding a name reference.\n        // If templateString includes at least one HTML tag, $.template( templateString ) is equivalent\n        // to $.template( null, templateString )\n        template: function( name, tmpl ) {\n            if (tmpl) {\n                // Compile template and associate with name\n                if ( typeof tmpl === \"string\" ) {\n                    // This is an HTML string being passed directly in.\n                    tmpl = buildTmplFn( tmpl )\n                } else if ( tmpl instanceof jQuery ) {\n                    tmpl = tmpl[0] || {};\n                }\n                if ( tmpl.nodeType ) {\n                    // If this is a template block, use cached copy, or generate tmpl function and cache.\n                    tmpl = jQuery.data( tmpl, \"tmpl\" ) || jQuery.data( tmpl, \"tmpl\", buildTmplFn( tmpl.innerHTML ));\n                }\n                return typeof name === \"string\" ? (jQuery.template[name] = tmpl) : tmpl;\n            }\n            // Return named compiled template\n            return name ? (typeof name !== \"string\" ? jQuery.template( null, name ):\n                (jQuery.template[name] ||\n                    // If not in map, treat as a selector. (If integrated with core, use quickExpr.exec)\n                    jQuery.template( null, htmlExpr.test( name ) ? name : jQuery( name )))) : null;\n        },\n\n        encode: function( text ) {\n            // Do HTML encoding replacing < > & and ' and \" by corresponding entities.\n            return (\"\" + text).split(\"<\").join(\"&lt;\").split(\">\").join(\"&gt;\").split('\"').join(\"&#34;\").split(\"'\").join(\"&#39;\");\n        }\n    });\n\n    jQuery.extend( jQuery.tmpl, {\n        tag: {\n            \"tmpl\": {\n                _default: { $2: \"null\" },\n                open: \"if($notnull_1){_=_.concat($item.nest($1,$2));}\"\n                // tmpl target parameter can be of type function, so use $1, not $1a (so not auto detection of functions)\n                // This means that {{tmpl foo}} treats foo as a template (which IS a function).\n                // Explicit parens can be used if foo is a function that returns a template: {{tmpl foo()}}.\n            },\n            \"wrap\": {\n                _default: { $2: \"null\" },\n                open: \"$item.calls(_,$1,$2);_=[];\",\n                close: \"call=$item.calls();_=call._.concat($item.wrap(call,_));\"\n            },\n            \"each\": {\n                _default: { $2: \"$index, $value\" },\n                open: \"if($notnull_1){$.each($1a,function($2){with(this){\",\n                close: \"}});}\"\n            },\n            \"if\": {\n                open: \"if(($notnull_1) && $1a){\",\n                close: \"}\"\n            },\n            \"else\": {\n                _default: { $1: \"true\" },\n                open: \"}else if(($notnull_1) && $1a){\"\n            },\n            \"html\": {\n                // Unecoded expression evaluation.\n                open: \"if($notnull_1){_.push($1a);}\"\n            },\n            \"=\": {\n                // Encoded expression evaluation. Abbreviated form is ${}.\n                _default: { $1: \"$data\" },\n                open: \"if($notnull_1){_.push($.encode($1a));}\"\n            },\n            \"!\": {\n                // Comment tag. Skipped by parser\n                open: \"\"\n            }\n        },\n\n        // This stub can be overridden, e.g. in jquery.tmplPlus for providing rendered events\n        complete: function( items ) {\n            newTmplItems = {};\n        },\n\n        // Call this from code which overrides domManip, or equivalent\n        // Manage cloning/storing template items etc.\n        afterManip: function afterManip( elem, fragClone, callback ) {\n            // Provides cloned fragment ready for fixup prior to and after insertion into DOM\n            var content = fragClone.nodeType === 11 ?\n                jQuery.makeArray(fragClone.childNodes) :\n                fragClone.nodeType === 1 ? [fragClone] : [];\n\n            // Return fragment to original caller (e.g. append) for DOM insertion\n            callback.call( elem, fragClone );\n\n            // Fragment has been inserted:- Add inserted nodes to tmplItem data structure. Replace inserted element annotations by jQuery.data.\n            storeTmplItems( content );\n            cloneIndex++;\n        }\n    });\n\n    //========================== Private helper functions, used by code above ==========================\n\n    function build( tmplItem, nested, content ) {\n        // Convert hierarchical content into flat string array\n        // and finally return array of fragments ready for DOM insertion\n        var frag, ret = content ? jQuery.map( content, function( item ) {\n            return (typeof item === \"string\") ?\n                // Insert template item annotations, to be converted to jQuery.data( \"tmplItem\" ) when elems are inserted into DOM.\n                (tmplItem.key ? item.replace( /(<\\w+)(?=[\\s>])(?![^>]*_tmplitem)([^>]*)/g, \"$1 \" + tmplItmAtt + \"=\\\"\" + tmplItem.key + \"\\\" $2\" ) : item) :\n                // This is a child template item. Build nested template.\n                build( item, tmplItem, item._ctnt );\n        }) :\n        // If content is not defined, insert tmplItem directly. Not a template item. May be a string, or a string array, e.g. from {{html $item.html()}}.\n        tmplItem;\n        if ( nested ) {\n            return ret;\n        }\n\n        // top-level template\n        ret = ret.join(\"\");\n\n        // Support templates which have initial or final text nodes, or consist only of text\n        // Also support HTML entities within the HTML markup.\n        ret.replace( /^\\s*([^<\\s][^<]*)?(<[\\w\\W]+>)([^>]*[^>\\s])?\\s*$/, function( all, before, middle, after) {\n            frag = jQuery( middle ).get();\n\n            storeTmplItems( frag );\n            if ( before ) {\n                frag = unencode( before ).concat(frag);\n            }\n            if ( after ) {\n                frag = frag.concat(unencode( after ));\n            }\n        });\n        return frag ? frag : unencode( ret );\n    }\n\n    function unencode( text ) {\n        // Use createElement, since createTextNode will not render HTML entities correctly\n        var el = document.createElement( \"div\" );\n        el.innerHTML = text;\n        return jQuery.makeArray(el.childNodes);\n    }\n\n    // Generate a reusable function that will serve to render a template against data\n    function buildTmplFn( markup ) {\n        return new Function(\"jQuery\",\"$item\",\n            \"var $=jQuery,call,_=[],$data=$item.data;\" +\n\n            // Introduce the data as local variables using with(){}\n            \"with($data){_.push('\" +\n\n            // Convert the template into pure JavaScript\n            jQuery.trim(markup)\n                .replace( /([\\\\'])/g, \"\\\\$1\" )\n                .replace( /[\\r\\t\\n]/g, \" \" )\n                .replace( /\\$\\{([^\\}]*)\\}/g, \"{{= $1}}\" )\n                .replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n                function( all, slash, type, fnargs, target, parens, args ) {\n                    var tag = jQuery.tmpl.tag[ type ], def, expr, exprAutoFnDetect;\n                    if ( !tag ) {\n                        throw \"Template command not found: \" + type;\n                    }\n                    def = tag._default || [];\n                    if ( parens && !/\\w$/.test(target)) {\n                        target += parens;\n                        parens = \"\";\n                    }\n                    if ( target ) {\n                        target = unescape( target );\n                        args = args ? (\",\" + unescape( args ) + \")\") : (parens ? \")\" : \"\");\n                        // Support for target being things like a.toLowerCase();\n                        // In that case don't call with template item as 'this' pointer. Just evaluate...\n                        expr = parens ? (target.indexOf(\".\") > -1 ? target + parens : (\"(\" + target + \").call($item\" + args)) : target;\n                        exprAutoFnDetect = parens ? expr : \"(typeof(\" + target + \")==='function'?(\" + target + \").call($item):(\" + target + \"))\";\n                    } else {\n                        exprAutoFnDetect = expr = def.$1 || \"null\";\n                    }\n                    fnargs = unescape( fnargs );\n                    return \"');\" +\n                        tag[ slash ? \"close\" : \"open\" ]\n                            .split( \"$notnull_1\" ).join( target ? \"typeof(\" + target + \")!=='undefined' && (\" + target + \")!=null\" : \"true\" )\n                            .split( \"$1a\" ).join( exprAutoFnDetect )\n                            .split( \"$1\" ).join( expr )\n                            .split( \"$2\" ).join( fnargs ?\n                                fnargs.replace( /\\s*([^\\(]+)\\s*(\\((.*?)\\))?/g, function( all, name, parens, params ) {\n                                    params = params ? (\",\" + params + \")\") : (parens ? \")\" : \"\");\n                                    return params ? (\"(\" + name + \").call($item\" + params) : all;\n                                })\n                                : (def.$2||\"\")\n                            ) +\n                        \"_.push('\";\n                }) +\n            \"');}return _;\"\n        );\n    }\n    function updateWrapped( options, wrapped ) {\n        // Build the wrapped content.\n        options._wrap = build( options, true,\n            // Suport imperative scenario in which options.wrapped can be set to a selector or an HTML string.\n            jQuery.isArray( wrapped ) ? wrapped : [htmlExpr.test( wrapped ) ? wrapped : jQuery( wrapped ).html()]\n        ).join(\"\");\n    }\n\n    function unescape( args ) {\n        return args ? args.replace( /\\\\'/g, \"'\").replace(/\\\\\\\\/g, \"\\\\\" ) : null;\n    }\n    function outerHtml( elem ) {\n        var div = document.createElement(\"div\");\n        div.appendChild( elem.cloneNode(true) );\n        return div.innerHTML;\n    }\n\n    // Store template items in jQuery.data(), ensuring a unique tmplItem data data structure for each rendered template instance.\n    function storeTmplItems( content ) {\n        var keySuffix = \"_\" + cloneIndex, elem, elems, newClonedItems = {}, i, l, m;\n        for ( i = 0, l = content.length; i < l; i++ ) {\n            if ( (elem = content[i]).nodeType !== 1 ) {\n                continue;\n            }\n            elems = elem.getElementsByTagName(\"*\");\n            for ( m = elems.length - 1; m >= 0; m-- ) {\n                processItemKey( elems[m] );\n            }\n            processItemKey( elem );\n        }\n        function processItemKey( el ) {\n            var pntKey, pntNode = el, pntItem, tmplItem, key;\n            // Ensure that each rendered template inserted into the DOM has its own template item,\n            if ( (key = el.getAttribute( tmplItmAtt ))) {\n                while ( pntNode.parentNode && (pntNode = pntNode.parentNode).nodeType === 1 && !(pntKey = pntNode.getAttribute( tmplItmAtt ))) { }\n                if ( pntKey !== key ) {\n                    // The next ancestor with a _tmplitem expando is on a different key than this one.\n                    // So this is a top-level element within this template item\n                    // Set pntNode to the key of the parentNode, or to 0 if pntNode.parentNode is null, or pntNode is a fragment.\n                    pntNode = pntNode.parentNode ? (pntNode.nodeType === 11 ? 0 : (pntNode.getAttribute( tmplItmAtt ) || 0)) : 0;\n                    if ( !(tmplItem = newTmplItems[key]) ) {\n                        // The item is for wrapped content, and was copied from the temporary parent wrappedItem.\n                        tmplItem = wrappedItems[key];\n                        tmplItem = newTmplItem( tmplItem, newTmplItems[pntNode]||wrappedItems[pntNode], null, true );\n                        tmplItem.key = ++itemKey;\n                        newTmplItems[itemKey] = tmplItem;\n                    }\n                    if ( cloneIndex ) {\n                        cloneTmplItem( key );\n                    }\n                }\n                el.removeAttribute( tmplItmAtt );\n            } else if ( cloneIndex && (tmplItem = jQuery.data( el, \"tmplItem\" )) ) {\n                // This was a rendered element, cloned during append or appendTo etc.\n                // TmplItem stored in jQuery data has already been cloned in cloneCopyEvent. We must replace it with a fresh cloned tmplItem.\n                cloneTmplItem( tmplItem.key );\n                newTmplItems[tmplItem.key] = tmplItem;\n                pntNode = jQuery.data( el.parentNode, \"tmplItem\" );\n                pntNode = pntNode ? pntNode.key : 0;\n            }\n            if ( tmplItem ) {\n                pntItem = tmplItem;\n                // Find the template item of the parent element.\n                // (Using !=, not !==, since pntItem.key is number, and pntNode may be a string)\n                while ( pntItem && pntItem.key != pntNode ) {\n                    // Add this element as a top-level node for this rendered template item, as well as for any\n                    // ancestor items between this item and the item of its parent element\n                    pntItem.nodes.push( el );\n                    pntItem = pntItem.parent;\n                }\n                // Delete content built during rendering - reduce API surface area and memory use, and avoid exposing of stale data after rendering...\n                delete tmplItem._ctnt;\n                delete tmplItem._wrap;\n                // Store template item as jQuery data on the element\n                jQuery.data( el, \"tmplItem\", tmplItem );\n            }\n            function cloneTmplItem( key ) {\n                key = key + keySuffix;\n                tmplItem = newClonedItems[key] =\n                    (newClonedItems[key] || newTmplItem( tmplItem, newTmplItems[tmplItem.parent.key + keySuffix] || tmplItem.parent, null, true ));\n            }\n        }\n    }\n\n    //---- Helper functions for template item ----\n\n    function tiCalls( content, tmpl, data, options ) {\n        if ( !content ) {\n            return stack.pop();\n        }\n        stack.push({ _: content, tmpl: tmpl, item:this, data: data, options: options });\n    }\n\n    function tiNest( tmpl, data, options ) {\n        // nested template, using {{tmpl}} tag\n        return jQuery.tmpl( jQuery.template( tmpl ), data, options, this );\n    }\n\n    function tiWrap( call, wrapped ) {\n        // nested template, using {{wrap}} tag\n        var options = call.options || {};\n        options.wrapped = wrapped;\n        // Apply the template, which may incorporate wrapped content,\n        return jQuery.tmpl( jQuery.template( call.tmpl ), call.data, options, call.item );\n    }\n\n    function tiHtml( filter, textOnly ) {\n        var wrapped = this._wrap;\n        return jQuery.map(\n            jQuery( jQuery.isArray( wrapped ) ? wrapped.join(\"\") : wrapped ).filter( filter || \"*\" ),\n            function(e) {\n                return textOnly ?\n                    e.innerText || e.textContent :\n                    e.outerHTML || outerHtml(e);\n            });\n    }\n\n    function tiUpdate() {\n        var coll = this.nodes;\n        jQuery.tmpl( null, null, null, this).insertBefore( coll[0] );\n        jQuery( coll ).remove();\n    }\n})( jQuery );\n"]},"metadata":{},"sourceType":"module"}