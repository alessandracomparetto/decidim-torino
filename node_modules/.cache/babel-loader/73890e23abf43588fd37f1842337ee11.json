{"ast":null,"code":"var focusGuardClass = \"focusguard\";\nvar focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nvar focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\n\nvar isFocusGuard = function isFocusGuard(element) {\n  return element.classList.contains(focusGuardClass);\n};\n\nvar isFocusable = function isFocusable(element) {\n  if (focusableNodes.indexOf(element.nodeName) > -1) {\n    return true;\n  }\n\n  if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n    if (element.getAttribute(\"disabled\")) {\n      return false;\n    }\n\n    return true;\n  }\n\n  var tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n\n  if (!isNaN(tabindex) && tabindex >= 0) {\n    return true;\n  }\n\n  return false;\n};\n\nvar createFocusGuard = function createFocusGuard(position) {\n  return $(\"<div class=\\\"\".concat(focusGuardClass, \"\\\" data-position=\\\"\").concat(position, \"\\\" tabindex=\\\"0\\\" aria-hidden=\\\"true\\\"></div>\"));\n};\n\nvar handleContainerFocus = function handleContainerFocus($container, $guard) {\n  var $reveal = $(\".reveal:visible:last\", $container);\n\n  if ($reveal.length > 0) {\n    handleContainerFocus($reveal, $guard);\n    return;\n  }\n\n  var $nodes = $(\"*:visible\", $container);\n  var $target = null;\n\n  if ($guard.data(\"position\") === \"start\") {\n    // Focus at the start guard, so focus the first focusable element after that\n    for (var ind = 0; ind < $nodes.length; ind += 1) {\n      if (!isFocusGuard($nodes[ind]) && isFocusable($nodes[ind])) {\n        $target = $($nodes[ind]);\n        break;\n      }\n    }\n  } else {\n    // Focus at the end guard, so focus the first focusable element after that\n    for (var _ind = $nodes.length - 1; _ind >= 0; _ind -= 1) {\n      if (!isFocusGuard($nodes[_ind]) && isFocusable($nodes[_ind])) {\n        $target = $($nodes[_ind]);\n        break;\n      }\n    }\n  }\n\n  if ($target) {\n    $target.trigger(\"focus\");\n  } else {\n    // If no focusable element was found, blur the guard focus\n    $guard.blur();\n  }\n};\n/**\n * A method to enable the dialog mode for the given dialog(s).\n *\n * This should be called when the dialog is opened. It implements two things for\n * the dialog:\n * 1. It places the focus to the title element making sure the screen reader\n *    focuses in the correct position of the document. Otherwise some screen\n *    readers continue reading outside of the document.\n * 2. Document \"tab guards\" that force the keyboard focus within the modal when\n *    the user is using keyboard or keyboard emulating devices for browsing the\n *    document.\n *\n * The \"tab guards\" are added at the top and bottom of the document to keep the\n * user's focus within the dialog if they accidentally or intentionally place\n * the focus outside of the document, e.g. in different window or in the browser\n * address bar. They guard the focus on both sides of the document returning\n * focus back to the first or last focusable element within the dialog.\n *\n * @param {jQuery} $dialogs The jQuery element(s) to apply the mode for.\n * @return {Void} Nothing\n */\n\n\nexport default (function ($dialogs) {\n  $dialogs.each(function (_i, dialog) {\n    var $dialog = $(dialog);\n    var $container = $(\"body\");\n    var $title = $(\".reveal__title:first\", $dialog);\n\n    if ($title.length > 0) {\n      // Focus on the title to make the screen reader to start reading the\n      // content within the modal.\n      $title.attr(\"tabindex\", $title.attr(\"tabindex\") || -1);\n      $title.trigger(\"focus\");\n    } // Once the final modal closes, remove the focus guards from the container\n\n\n    $dialog.off(\"closed.zf.reveal.focusguard\").on(\"closed.zf.reveal.focusguard\", function () {\n      $dialog.off(\"closed.zf.reveal.focusguard\"); // After the last dialog is closed, the tab guards should be removed.\n      // Note that there may be multiple dialogs open on top of each other at\n      // the same time.\n\n      if ($(\".reveal:visible\", $container).length < 1) {\n        $(\"> .\".concat(focusGuardClass), $container).remove();\n      }\n    }); // Check if the guards already exists due to some other dialog\n\n    var $guards = $(\"> .\".concat(focusGuardClass), $container);\n\n    if ($guards.length > 0) {\n      // Make sure the guards are the first and last element as there have\n      // been changes in the DOM.\n      $guards.each(function (_j, guard) {\n        var $guard = $(guard);\n\n        if ($guard.data(\"position\") === \"start\") {\n          $container.prepend($guard);\n        } else {\n          $container.append($guard);\n        }\n      });\n      return;\n    } // Add guards at the start and end of the document and attach their focus\n    // listeners\n\n\n    var $startGuard = createFocusGuard(\"start\");\n    var $endGuard = createFocusGuard(\"end\");\n    $container.prepend($startGuard);\n    $container.append($endGuard);\n    $startGuard.on(\"focus\", function () {\n      return handleContainerFocus($container, $startGuard);\n    });\n    $endGuard.on(\"focus\", function () {\n      return handleContainerFocus($container, $endGuard);\n    });\n  });\n});","map":{"version":3,"mappings":"AAAA,IAAMA,eAAe,GAAG,YAAxB;AACA,IAAMC,cAAc,GAAG,CAAC,GAAD,EAAM,QAAN,EAAgB,QAAhB,EAA0B,OAA1B,CAAvB;AACA,IAAMC,yBAAyB,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,UAApB,EAAgC,QAAhC,CAAlC;;AAEA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACC,OAAD,EAAa;AAChC,SAAOA,OAAO,CAACC,SAARD,CAAkBE,QAAlBF,CAA2BJ,eAA3BI,CAAP;AADF;;AAIA,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACH,OAAD,EAAa;AAC/B,MAAIH,cAAc,CAACO,OAAfP,CAAuBG,OAAO,CAACK,QAA/BR,IAA2C,CAAC,CAAhD,EAAmD;AACjD,WAAO,IAAP;AACD;;AACD,MAAIC,yBAAyB,CAACM,OAA1BN,CAAkCE,OAAO,CAACK,QAA1CP,IAAsD,CAAC,CAAvDA,IAA4DE,OAAO,CAACM,YAARN,CAAqB,iBAArBA,CAAhE,EAAyG;AACvG,QAAIA,OAAO,CAACM,YAARN,CAAqB,UAArBA,CAAJ,EAAsC;AACpC,aAAO,KAAP;AACD;;AACD,WAAO,IAAP;AACD;;AAED,MAAMO,QAAQ,GAAGC,QAAQ,CAACR,OAAO,CAACM,YAARN,CAAqB,UAArBA,CAAD,EAAmC,EAAnC,CAAzB;;AACA,MAAI,CAACS,KAAK,CAACF,QAAD,CAAN,IAAoBA,QAAQ,IAAI,CAApC,EAAuC;AACrC,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AAhBF;;AAmBA,IAAMG,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,QAAD,EAAc;AACrC,SAAOC,CAAC,wBAAgBhB,eAAhB,gCAAmDe,QAAnD,mDAAR;AADF;;AAIA,IAAME,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,UAAD,EAAaC,MAAb,EAAwB;AACnD,MAAMC,OAAO,GAAGJ,CAAC,CAAC,sBAAD,EAAyBE,UAAzB,CAAjB;;AACA,MAAIE,OAAO,CAACC,MAARD,GAAiB,CAArB,EAAwB;AACtBH,wBAAoB,CAACG,OAAD,EAAUD,MAAV,CAApBF;AACA;AACD;;AAED,MAAMK,MAAM,GAAGN,CAAC,CAAC,WAAD,EAAcE,UAAd,CAAhB;AACA,MAAIK,OAAO,GAAG,IAAd;;AAEA,MAAIJ,MAAM,CAACK,IAAPL,CAAY,UAAZA,MAA4B,OAAhC,EAAyC;AACvC;AACA,SAAK,IAAIM,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGH,MAAM,CAACD,MAA/B,EAAuCI,GAAG,IAAI,CAA9C,EAAiD;AAC/C,UAAI,CAACtB,YAAY,CAACmB,MAAM,CAACG,GAAD,CAAP,CAAb,IAA8BlB,WAAW,CAACe,MAAM,CAACG,GAAD,CAAP,CAA7C,EAA4D;AAC1DF,eAAO,GAAGP,CAAC,CAACM,MAAM,CAACG,GAAD,CAAP,CAAXF;AACA;AACD;AACF;AAPH,SAQO;AACL;AACA,SAAK,IAAIE,IAAG,GAAGH,MAAM,CAACD,MAAPC,GAAgB,CAA/B,EAAkCG,IAAG,IAAI,CAAzC,EAA4CA,IAAG,IAAI,CAAnD,EAAsD;AACpD,UAAI,CAACtB,YAAY,CAACmB,MAAM,CAACG,IAAD,CAAP,CAAb,IAA8BlB,WAAW,CAACe,MAAM,CAACG,IAAD,CAAP,CAA7C,EAA4D;AAC1DF,eAAO,GAAGP,CAAC,CAACM,MAAM,CAACG,IAAD,CAAP,CAAXF;AACA;AACD;AACF;AACF;;AAED,MAAIA,OAAJ,EAAa;AACXA,WAAO,CAACG,OAARH,CAAgB,OAAhBA;AADF,SAEO;AACL;AACAJ,UAAM,CAACQ,IAAPR;AACD;AAjCH;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,gBAAe,UAACS,QAAD,EAAc;AAC3BA,UAAQ,CAACC,IAATD,CAAc,UAACE,EAAD,EAAKC,MAAL,EAAgB;AAC5B,QAAMC,OAAO,GAAGhB,CAAC,CAACe,MAAD,CAAjB;AAEA,QAAMb,UAAU,GAAGF,CAAC,CAAC,MAAD,CAApB;AACA,QAAMiB,MAAM,GAAGjB,CAAC,CAAC,sBAAD,EAAyBgB,OAAzB,CAAhB;;AAEA,QAAIC,MAAM,CAACZ,MAAPY,GAAgB,CAApB,EAAuB;AACrB;AACA;AACAA,YAAM,CAACC,IAAPD,CAAY,UAAZA,EAAwBA,MAAM,CAACC,IAAPD,CAAY,UAAZA,KAA2B,CAAC,CAApDA;AACAA,YAAM,CAACP,OAAPO,CAAe,OAAfA;AAV0B,MAa5B;;;AACAD,WAAO,CAACG,GAARH,CAAY,6BAAZA,EAA2CI,EAA3CJ,CAA8C,6BAA9CA,EAA6E,YAAM;AACjFA,aAAO,CAACG,GAARH,CAAY,6BAAZA,EADiF,CAGjF;AACA;AACA;;AACA,UAAIhB,CAAC,CAAC,iBAAD,EAAoBE,UAApB,CAADF,CAAiCK,MAAjCL,GAA0C,CAA9C,EAAiD;AAC/CA,SAAC,cAAOhB,eAAP,GAA0BkB,UAA1B,CAADF,CAAuCqB,MAAvCrB;AACD;AARH,OAd4B,CAyB5B;;AACA,QAAMsB,OAAO,GAAGtB,CAAC,cAAOhB,eAAP,GAA0BkB,UAA1B,CAAjB;;AACA,QAAIoB,OAAO,CAACjB,MAARiB,GAAiB,CAArB,EAAwB;AACtB;AACA;AACAA,aAAO,CAACT,IAARS,CAAa,UAACC,EAAD,EAAKC,KAAL,EAAe;AAC1B,YAAMrB,MAAM,GAAGH,CAAC,CAACwB,KAAD,CAAhB;;AACA,YAAIrB,MAAM,CAACK,IAAPL,CAAY,UAAZA,MAA4B,OAAhC,EAAyC;AACvCD,oBAAU,CAACuB,OAAXvB,CAAmBC,MAAnBD;AADF,eAEO;AACLA,oBAAU,CAACwB,MAAXxB,CAAkBC,MAAlBD;AACD;AANH;AASA;AAvC0B,MA0C5B;AACA;;;AACA,QAAMyB,WAAW,GAAG7B,gBAAgB,CAAC,OAAD,CAApC;AACA,QAAM8B,SAAS,GAAG9B,gBAAgB,CAAC,KAAD,CAAlC;AAEAI,cAAU,CAACuB,OAAXvB,CAAmByB,WAAnBzB;AACAA,cAAU,CAACwB,MAAXxB,CAAkB0B,SAAlB1B;AAEAyB,eAAW,CAACP,EAAZO,CAAe,OAAfA,EAAwB;AAAA,aAAM1B,oBAAoB,CAACC,UAAD,EAAayB,WAAb,CAA1B;AAAxB;AACAC,aAAS,CAACR,EAAVQ,CAAa,OAAbA,EAAsB;AAAA,aAAM3B,oBAAoB,CAACC,UAAD,EAAa0B,SAAb,CAA1B;AAAtB;AAnDF;AADF","names":["focusGuardClass","focusableNodes","focusableDisableableNodes","isFocusGuard","element","classList","contains","isFocusable","indexOf","nodeName","getAttribute","tabindex","parseInt","isNaN","createFocusGuard","position","$","handleContainerFocus","$container","$guard","$reveal","length","$nodes","$target","data","ind","trigger","blur","$dialogs","each","_i","dialog","$dialog","$title","attr","off","on","remove","$guards","_j","guard","prepend","append","$startGuard","$endGuard"],"sources":["/var/lib/gems/2.7.0/gems/decidim-core-0.26.0/app/packs/src/decidim/dialog_mode.js"],"sourcesContent":["const focusGuardClass = \"focusguard\";\nconst focusableNodes = [\"A\", \"IFRAME\", \"OBJECT\", \"EMBED\"];\nconst focusableDisableableNodes = [\"BUTTON\", \"INPUT\", \"TEXTAREA\", \"SELECT\"];\n\nconst isFocusGuard = (element) => {\n  return element.classList.contains(focusGuardClass);\n}\n\nconst isFocusable = (element) => {\n  if (focusableNodes.indexOf(element.nodeName) > -1) {\n    return true;\n  }\n  if (focusableDisableableNodes.indexOf(element.nodeName) > -1 || element.getAttribute(\"contenteditable\")) {\n    if (element.getAttribute(\"disabled\")) {\n      return false;\n    }\n    return true;\n  }\n\n  const tabindex = parseInt(element.getAttribute(\"tabindex\"), 10);\n  if (!isNaN(tabindex) && tabindex >= 0) {\n    return true;\n  }\n\n  return false;\n}\n\nconst createFocusGuard = (position) => {\n  return $(`<div class=\"${focusGuardClass}\" data-position=\"${position}\" tabindex=\"0\" aria-hidden=\"true\"></div>`);\n};\n\nconst handleContainerFocus = ($container, $guard) => {\n  const $reveal = $(\".reveal:visible:last\", $container);\n  if ($reveal.length > 0) {\n    handleContainerFocus($reveal, $guard);\n    return;\n  }\n\n  const $nodes = $(\"*:visible\", $container);\n  let $target = null;\n\n  if ($guard.data(\"position\") === \"start\") {\n    // Focus at the start guard, so focus the first focusable element after that\n    for (let ind = 0; ind < $nodes.length; ind += 1) {\n      if (!isFocusGuard($nodes[ind]) && isFocusable($nodes[ind])) {\n        $target = $($nodes[ind]);\n        break;\n      }\n    }\n  } else {\n    // Focus at the end guard, so focus the first focusable element after that\n    for (let ind = $nodes.length - 1; ind >= 0; ind -= 1) {\n      if (!isFocusGuard($nodes[ind]) && isFocusable($nodes[ind])) {\n        $target = $($nodes[ind]);\n        break;\n      }\n    }\n  }\n\n  if ($target) {\n    $target.trigger(\"focus\");\n  } else {\n    // If no focusable element was found, blur the guard focus\n    $guard.blur();\n  }\n};\n\n/**\n * A method to enable the dialog mode for the given dialog(s).\n *\n * This should be called when the dialog is opened. It implements two things for\n * the dialog:\n * 1. It places the focus to the title element making sure the screen reader\n *    focuses in the correct position of the document. Otherwise some screen\n *    readers continue reading outside of the document.\n * 2. Document \"tab guards\" that force the keyboard focus within the modal when\n *    the user is using keyboard or keyboard emulating devices for browsing the\n *    document.\n *\n * The \"tab guards\" are added at the top and bottom of the document to keep the\n * user's focus within the dialog if they accidentally or intentionally place\n * the focus outside of the document, e.g. in different window or in the browser\n * address bar. They guard the focus on both sides of the document returning\n * focus back to the first or last focusable element within the dialog.\n *\n * @param {jQuery} $dialogs The jQuery element(s) to apply the mode for.\n * @return {Void} Nothing\n */\nexport default ($dialogs) => {\n  $dialogs.each((_i, dialog) => {\n    const $dialog = $(dialog);\n\n    const $container = $(\"body\");\n    const $title = $(\".reveal__title:first\", $dialog);\n\n    if ($title.length > 0) {\n      // Focus on the title to make the screen reader to start reading the\n      // content within the modal.\n      $title.attr(\"tabindex\", $title.attr(\"tabindex\") || -1);\n      $title.trigger(\"focus\");\n    }\n\n    // Once the final modal closes, remove the focus guards from the container\n    $dialog.off(\"closed.zf.reveal.focusguard\").on(\"closed.zf.reveal.focusguard\", () => {\n      $dialog.off(\"closed.zf.reveal.focusguard\");\n\n      // After the last dialog is closed, the tab guards should be removed.\n      // Note that there may be multiple dialogs open on top of each other at\n      // the same time.\n      if ($(\".reveal:visible\", $container).length < 1) {\n        $(`> .${focusGuardClass}`, $container).remove();\n      }\n    });\n\n    // Check if the guards already exists due to some other dialog\n    const $guards = $(`> .${focusGuardClass}`, $container);\n    if ($guards.length > 0) {\n      // Make sure the guards are the first and last element as there have\n      // been changes in the DOM.\n      $guards.each((_j, guard) => {\n        const $guard = $(guard);\n        if ($guard.data(\"position\") === \"start\") {\n          $container.prepend($guard);\n        } else {\n          $container.append($guard);\n        }\n      });\n\n      return;\n    }\n\n    // Add guards at the start and end of the document and attach their focus\n    // listeners\n    const $startGuard = createFocusGuard(\"start\");\n    const $endGuard = createFocusGuard(\"end\");\n\n    $container.prepend($startGuard);\n    $container.append($endGuard);\n\n    $startGuard.on(\"focus\", () => handleContainerFocus($container, $startGuard));\n    $endGuard.on(\"focus\", () => handleContainerFocus($container, $endGuard));\n  });\n};\n"]},"metadata":{},"sourceType":"module"}