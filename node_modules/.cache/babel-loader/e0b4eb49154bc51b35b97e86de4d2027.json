{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar COUNT_KEY = \"%count%\";\nvar DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: \"at least \".concat(COUNT_KEY, \" character\"),\n    other: \"at least \".concat(COUNT_KEY, \" characters\")\n  },\n  charactersLeft: {\n    one: \"\".concat(COUNT_KEY, \" character left\"),\n    other: \"\".concat(COUNT_KEY, \" characters left\")\n  }\n};\nvar MESSAGES = DEFAULT_MESSAGES;\n\nvar InputCharacterCounter = /*#__PURE__*/function () {\n  function InputCharacterCounter(input) {\n    _classCallCheck(this, InputCharacterCounter);\n\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n\n    if (this.$target.length < 1) {\n      var targetId = null;\n\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = \"\".concat(this.$input.attr(\"id\"), \"_characters\");\n      } else {\n        targetId = \"characters_\".concat(Math.random().toString(36).substr(2, 9));\n      }\n\n      this.$target = $(\"<span id=\\\"\".concat(targetId, \"\\\" class=\\\"form-input-extra-before\\\" />\")); // If input is a hidden for WYSIWYG editor add it at the end\n\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      } // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (this.$input.parent().is(\".columns\") && this.$input.parent().parent().is(\".row\")) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      this.bindEvents();\n    }\n  }\n\n  _createClass(InputCharacterCounter, [{\n    key: \"bindEvents\",\n    value: function bindEvents() {\n      var _this = this; // In WYSIWYG editors (Quill) we need to find the active editor from the\n      // DOM node. Quill has the experimental \"find\" method that should work\n      // fine in this case\n\n\n      if (Quill && this.$input.parent().is(\".editor\")) {\n        // Wait until the next javascript loop so Quill editors are created\n        setTimeout(function () {\n          var editor = Quill.find(_this.$input.siblings(\".editor-container\")[0]);\n          editor.on(\"text-change\", function () {\n            _this.updateStatus();\n          });\n        });\n      }\n\n      this.$input.on(\"keyup\", function () {\n        _this.updateStatus();\n      });\n\n      if (this.$input.get(0) !== null) {\n        this.$input.get(0).addEventListener(\"emoji.added\", function () {\n          _this.updateStatus();\n        });\n      }\n\n      this.updateStatus();\n    }\n  }, {\n    key: \"updateStatus\",\n    value: function updateStatus() {\n      var numCharacters = this.$input.val().length;\n      var showMessages = [];\n\n      if (this.minCharacters > 0) {\n        var message = MESSAGES.charactersAtLeast.other;\n\n        if (this.minCharacters === 1) {\n          message = MESSAGES.charactersAtLeast.one;\n        }\n\n        showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n      }\n\n      if (this.maxCharacters > 0) {\n        var remaining = this.maxCharacters - numCharacters;\n        var _message = MESSAGES.charactersLeft.other;\n\n        if (remaining === 1) {\n          _message = MESSAGES.charactersLeft.one;\n        }\n\n        showMessages.push(_message.replace(COUNT_KEY, remaining));\n      }\n\n      this.$target.text(showMessages.join(\", \"));\n    }\n  }], [{\n    key: \"configureMessages\",\n    value: function configureMessages(messages) {\n      MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n    }\n  }]);\n\n  return InputCharacterCounter;\n}();\n\nexport { InputCharacterCounter as default };\n\nvar createCharacterCounter = function createCharacterCounter($input) {\n  $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n};\n\n$(function () {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each(function (_i, elem) {\n    var $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\nexport { InputCharacterCounter, createCharacterCounter };","map":{"version":3,"mappings":"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","names":["COUNT_KEY","DEFAULT_MESSAGES","charactersAtLeast","one","other","charactersLeft","MESSAGES","InputCharacterCounter","input","_classCallCheck","$input","$target","$","data","minCharacters","parseInt","attr","maxCharacters","length","targetId","Math","random","toString","substr","parent","is","after","bindEvents","Quill","setTimeout","editor","find","_this","siblings","on","updateStatus","get","addEventListener","numCharacters","val","showMessages","message","push","replace","remaining","text","join","messages","extend","createCharacterCounter","each","_i","elem"],"sources":["/var/lib/gems/2.7.0/gems/decidim-core-0.26.0/app/packs/src/decidim/input_character_counter.js"],"sourcesContent":["const COUNT_KEY = \"%count%\";\nconst DEFAULT_MESSAGES = {\n  charactersAtLeast: {\n    one: `at least ${COUNT_KEY} character`,\n    other: `at least ${COUNT_KEY} characters`\n  },\n  charactersLeft: {\n    one: `${COUNT_KEY} character left`,\n    other: `${COUNT_KEY} characters left`\n  }\n};\nlet MESSAGES = DEFAULT_MESSAGES;\n\nexport default class InputCharacterCounter {\n  static configureMessages(messages) {\n    MESSAGES = $.extend(DEFAULT_MESSAGES, messages);\n  }\n\n  constructor(input) {\n    this.$input = input;\n    this.$target = $(this.$input.data(\"remaining-characters\"));\n    this.minCharacters = parseInt(this.$input.attr(\"minlength\"), 10);\n    this.maxCharacters = parseInt(this.$input.attr(\"maxlength\"), 10);\n\n    if (this.$target.length < 1) {\n      let targetId = null;\n      if (this.$input.attr(\"id\") && this.$input.attr(\"id\").length > 0) {\n        targetId = `${this.$input.attr(\"id\")}_characters`;\n      } else {\n        targetId = `characters_${Math.random().toString(36).substr(2, 9)}`;\n      }\n\n      this.$target = $(`<span id=\"${targetId}\" class=\"form-input-extra-before\" />`)\n\n      // If input is a hidden for WYSIWYG editor add it at the end\n      if (this.$input.parent().is(\".editor\")) {\n        this.$input.parent().after(this.$target);\n      }\n      // Prefix and suffix columns are wrapped in columns, so put the\n      // character counter before that.\n      else if (\n        this.$input.parent().is(\".columns\") &&\n        this.$input.parent().parent().is(\".row\")\n      ) {\n        this.$input.parent().parent().after(this.$target);\n      } else {\n        this.$input.after(this.$target);\n      }\n    }\n\n    if (this.$target.length > 0 && (this.maxCharacters > 0 || this.minCharacters > 0)) {\n      this.bindEvents();\n    }\n  }\n\n  bindEvents() {\n    // In WYSIWYG editors (Quill) we need to find the active editor from the\n    // DOM node. Quill has the experimental \"find\" method that should work\n    // fine in this case\n    if (Quill && this.$input.parent().is(\".editor\")) {\n      // Wait until the next javascript loop so Quill editors are created\n      setTimeout(() => {\n        const editor = Quill.find(this.$input.siblings(\".editor-container\")[0]);\n        editor.on(\"text-change\", () => {\n          this.updateStatus();\n        });\n      })\n    }\n    this.$input.on(\"keyup\", () => {\n      this.updateStatus();\n    });\n    if (this.$input.get(0) !== null) {\n      this.$input.get(0).addEventListener(\"emoji.added\", () => {\n        this.updateStatus();\n      });\n    }\n    this.updateStatus();\n  }\n\n  updateStatus() {\n    const numCharacters = this.$input.val().length;\n    const showMessages = [];\n\n    if (this.minCharacters > 0) {\n      let message = MESSAGES.charactersAtLeast.other;\n      if (this.minCharacters === 1) {\n        message = MESSAGES.charactersAtLeast.one;\n      }\n      showMessages.push(message.replace(COUNT_KEY, this.minCharacters));\n    }\n\n    if (this.maxCharacters > 0) {\n      const remaining = this.maxCharacters - numCharacters;\n      let message = MESSAGES.charactersLeft.other;\n      if (remaining === 1) {\n        message = MESSAGES.charactersLeft.one;\n      }\n      showMessages.push(message.replace(COUNT_KEY, remaining));\n    }\n\n    this.$target.text(showMessages.join(\", \"));\n  }\n}\n\nconst createCharacterCounter = ($input) => {\n  $input.data(\"remaining-characters-counter\", new InputCharacterCounter($input));\n}\n\n$(() => {\n  $(\"input[type='text'], textarea, .editor>input[type='hidden']\").each((_i, elem) => {\n    const $input = $(elem);\n\n    if (!$input.is(\"[minlength]\") && !$input.is(\"[maxlength]\")) {\n      return;\n    }\n\n    createCharacterCounter($input);\n  });\n});\n\nexport { InputCharacterCounter, createCharacterCounter };\n"]},"metadata":{},"sourceType":"module"}